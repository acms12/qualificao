VygotEA: Chatbot de Apoio Socioemocional Baseado em ABA para Estudantes com TEA
# Implementação completa com base de dados sintética e treinamento da IA

import pandas as pd
import numpy as np
import json
import random
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional
import re
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report, accuracy_score
import matplotlib.pyplot as plt
import seaborn as sns
from collections import defaultdict
import warnings
warnings.filterwarnings('ignore')

class SyntheticDataGenerator:
    """Gerador de dados sintéticos para estudantes com TEA"""

    def __init__(self):
        self.student_profiles = {
            'perfil_1': {
                'idade': 15,
                'nivel_desenvolvimento': 'intermediario',
                'caracteristicas': ['ansiedade_social', 'sensibilidade_sensorial', 'interesse_restrito_tecnologia'],
                'habilidades_sociais': 3,  # escala 1-5
                'autorregulacao': 2,
                'comunicacao': 4
            },
            'perfil_2': {
                'idade': 16,
                'nivel_desenvolvimento': 'avancado',
                'caracteristicas': ['perfeccionismo', 'dificuldade_mudancas', 'boa_memoria'],
                'habilidades_sociais': 4,
                'autorregulacao': 3,
                'comunicacao': 5
            },
            'perfil_3': {
                'idade': 14,
                'nivel_desenvolvimento': 'inicial',
                'caracteristicas': ['dificuldade_expressao', 'comportamento_repetitivo', 'sensibilidade_ruido'],
                'habilidades_sociais': 2,
                'autorregulacao': 2,
                'comunicacao': 2
            },
            'perfil_4': {
                'idade': 17,
                'nivel_desenvolvimento': 'avancado',
                'caracteristicas': ['alta_funcionalidade', 'interesse_ciencias', 'dificuldade_interpretacao_social'],
                'habilidades_sociais': 3,
                'autorregulacao': 4,
                'comunicacao': 4
            },
            'perfil_5': {
                'idade': 15,
                'nivel_desenvolvimento': 'intermediario',
                'caracteristicas': ['ansiedade_performance', 'rotinas_rigidas', 'interesse_arte'],
                'habilidades_sociais': 3,
                'autorregulacao': 3,
                'comunicacao': 3
            }
        }

        self.situacoes_contextuais = [
            'prova_aproximando', 'conflito_colega', 'mudanca_rotina', 'apresentacao_publica',
            'barulho_excessivo', 'tarefa_dificil', 'recreio_sozinho', 'elogio_professor',
            'critica_trabalho', 'atividade_grupo', 'dia_chuva', 'substituicao_professor'
        ]

        self.emocoes_categorias = {
            'ansiedade': ['nervoso', 'preocupado', 'tenso', 'inquieto', 'apreensivo'],
            'frustacao': ['irritado', 'chateado', 'desapontado', 'impaciente', 'zangado'],
            'tristeza': ['triste', 'desanimado', 'melancólico', 'abatido', 'deprimido'],
            'alegria': ['feliz', 'animado', 'contente', 'eufórico', 'satisfeito'],
            'medo': ['assustado', 'receoso', 'temeroso', 'aterrorizado', 'inseguro'],
            'calma': ['tranquilo', 'sereno', 'relaxado', 'pacífico', 'equilibrado']
        }

        self.estrategias_aba = {
            'autorregulacao': [
                'respiracao_profunda', 'contagem_regressiva', 'visualizacao_positiva',
                'pausas_programadas', 'automonitoramento', 'relaxamento_muscular'
            ],
            'habilidades_sociais': [
                'modelagem_comportamento', 'role_play', 'feedback_positivo',
                'ensino_direto', 'pratica_guiada', 'generalizacao'
            ],
            'comunicacao': [
                'linguagem_clara', 'apoio_visual', 'tempo_processamento',
                'validacao_emocional', 'reformulacao', 'pergunta_aberta'
            ]
        }

    def generate_student_interactions(self, num_interactions: int = 500) -> pd.DataFrame:
        """Gera interações sintéticas entre estudantes e o chatbot"""

        interactions = []

        for i in range(num_interactions):
            # Seleciona perfil aleatório
            profile_id = random.choice(list(self.student_profiles.keys()))
            profile = self.student_profiles[profile_id]

            # Gera situação contextual
            situacao = random.choice(self.situacoes_contextuais)

            # Seleciona emoção baseada no perfil e situação
            emocao_categoria = self._select_emotion_category(profile, situacao)
            emocao = random.choice(self.emocoes_categorias[emocao_categoria])

            # Gera mensagem do estudante
            mensagem_estudante = self._generate_student_message(profile, situacao, emocao)

            # Gera resposta do chatbot baseada em ABA e ZDP
            resposta_chatbot = self._generate_chatbot_response(profile_id, emocao_categoria, situacao)

            # Calcula progresso adaptativo
            progresso = self._calculate_adaptive_progress(profile, i)

            interactions.append({
                'interaction_id': i + 1,
                'student_profile': profile_id,
                'timestamp': datetime.now() - timedelta(days=random.randint(0, 30)),
                'situacao_contextual': situacao,
                'emocao_categoria': emocao_categoria,
                'emocao_especifica': emocao,
                'mensagem_estudante': mensagem_estudante,
                'resposta_chatbot': resposta_chatbot,
                'estrategia_aba': self._select_aba_strategy(emocao_categoria),
                'nivel_zdp': self._determine_zdp_level(profile),
                'progresso_adaptativo': progresso,
                'satisfacao_resposta': random.uniform(3.5, 5.0),  # Simulando feedback positivo
                'duracao_interacao': random.randint(30, 300)  # segundos
            })

        return pd.DataFrame(interactions)

    def _select_emotion_category(self, profile: Dict, situacao: str) -> str:
        """Seleciona categoria emocional baseada no perfil e situação"""

        # Mapeamento situação -> emoção mais provável
        situacao_emocao = {
            'prova_aproximando': 'ansiedade',
            'conflito_colega': 'frustacao',
            'mudanca_rotina': 'ansiedade',
            'apresentacao_publica': 'medo',
            'barulho_excessivo': 'frustacao',
            'tarefa_dificil': 'frustacao',
            'recreio_sozinho': 'tristeza',
            'elogio_professor': 'alegria',
            'critica_trabalho': 'tristeza',
            'atividade_grupo': 'ansiedade',
            'dia_chuva': 'calma',
            'substituicao_professor': 'ansiedade'
        }

        # Modifica probabilidade baseada no perfil
        base_emotion = situacao_emocao.get(situacao, 'ansiedade')

        if profile['autorregulacao'] >= 4:
            # Estudantes com melhor autorregulação tendem a ficar mais calmos
            return random.choice([base_emotion, 'calma'])

        return base_emotion

    def _generate_student_message(self, profile: Dict, situacao: str, emocao: str) -> str:
        """Gera mensagem do estudante baseada no contexto"""

        templates = {
            'ansiedade': [
                f"Estou {emocao} com {situacao.replace('_', ' ')}",
                f"Não consigo parar de pensar na {situacao.replace('_', ' ')}",
                f"Me sinto {emocao} e não sei o que fazer"
            ],
            'frustacao': [
                f"Estou {emocao} porque {situacao.replace('_', ' ')}",
                f"Isso é muito difícil, me sinto {emocao}",
                f"Não consigo lidar com {situacao.replace('_', ' ')}"
            ],
            'tristeza': [
                f"Me sinto {emocao} hoje",
                f"Estou {emocao} por causa de {situacao.replace('_', ' ')}",
                f"Não estou bem, me sinto {emocao}"
            ],
            'alegria': [
                f"Estou {emocao} com {situacao.replace('_', ' ')}",
                f"Me sinto {emocao} hoje!",
                f"Que bom, estou {emocao}!"
            ],
            'medo': [
                f"Estou {emocao} com {situacao.replace('_', ' ')}",
                f"Tenho medo de {situacao.replace('_', ' ')}",
                f"Me sinto {emocao} e inseguro"
            ],
            'calma': [
                f"Estou {emocao} hoje",
                f"Me sinto {emocao} e bem",
                f"Estou {emocao} apesar de {situacao.replace('_', ' ')}"
            ]
        }

        # Seleciona categoria emocional
        emotion_category = None
        for category, emotions in self.emocoes_categorias.items():
            if emocao in emotions:
                emotion_category = category
                break

        if emotion_category and emotion_category in templates:
            return random.choice(templates[emotion_category])

        return f"Estou me sentindo {emocao} hoje"

    def _generate_chatbot_response(self, profile_id: str, emocao_categoria: str, situacao: str) -> str:
        """Gera resposta do chatbot baseada em ABA e ZDP"""

        # Estratégias baseadas em ABA
        estrategias = {
            'ansiedade': [
                "Percebo que você está se sentindo ansioso. Vamos tentar uma técnica de respiração juntos?",
                "Entendo sua preocupação. Que tal dividirmos essa situação em partes menores?",
                "Você está sendo muito corajoso ao compartilhar isso. Vamos pensar em estratégias?"
            ],
            'frustacao': [
                "Vejo que você está frustrado. Isso é normal e compreensível. Vamos conversar sobre isso?",
                "Suas emoções são válidas. Que tal tentarmos uma abordagem diferente para essa situação?",
                "Percebo sua frustração. Vamos pausar e pensar juntos em uma solução?"
            ],
            'tristeza': [
                "Obrigado por compartilhar como está se sentindo. Estou aqui para apoiá-lo.",
                "Entendo que você está passando por um momento difícil. Vamos conversar sobre isso?",
                "Suas emoções são importantes. Como posso ajudá-lo a se sentir melhor?"
            ],
            'alegria': [
                "Que maravilha saber que você está se sentindo bem! Conte-me mais sobre isso.",
                "Fico feliz em saber que você está animado! Vamos celebrar esse momento positivo.",
                "Sua alegria é contagiante! Como podemos manter esse sentimento positivo?"
            ],
            'medo': [
                "Entendo que você está com medo. Vamos enfrentar isso juntos, passo a passo.",
                "Seus medos são válidos. Que tal conversarmos sobre estratégias para se sentir mais seguro?",
                "Obrigado por confiar em mim. Vamos trabalhar juntos para superar esse medo."
            ],
            'calma': [
                "Que bom saber que você está se sentindo tranquilo! Como conseguiu alcançar essa calma?",
                "Sua serenidade é admirável. Vamos aproveitar esse momento para planejar estratégias futuras?",
                "Fico feliz em saber que você está em equilíbrio. Vamos manter esse bem-estar?"
            ]
        }

        # Adapta resposta ao nível ZDP
        nivel_zdp = self.student_profiles[profile_id].get('nivel_desenvolvimento', 'intermediario')
        base_response = random.choice(estrategias.get(emocao_categoria, estrategias['ansiedade']))

        if nivel_zdp == 'inicial':
            # Linguagem mais simples e direta
            return base_response + " Vamos começar com algo bem simples."
        elif nivel_zdp == 'avancado':
            # Linguagem mais elaborada e estratégias complexas
            return base_response + " Podemos explorar estratégias mais elaboradas para lidar com essa situação."
        else:
            # Nível intermediário
            return base_response + " Vamos trabalhar nisso juntos, no seu ritmo."

    def _select_aba_strategy(self, emocao_categoria: str) -> str:
        """Seleciona estratégia ABA baseada na emoção"""

        if emocao_categoria in ['ansiedade', 'medo']:
            return random.choice(self.estrategias_aba['autorregulacao'])
        elif emocao_categoria in ['frustacao', 'tristeza']:
            return random.choice(self.estrategias_aba['habilidades_sociais'])
        else:
            return random.choice(self.estrategias_aba['comunicacao'])

    def _determine_zdp_level(self, profile: Dict) -> str:
        """Determina nível ZDP baseado no perfil"""
        return profile['nivel_desenvolvimento']

    def _calculate_adaptive_progress(self, profile: Dict, interaction_num: int) -> float:
        """Calcula progresso adaptativo usando a fórmula do artigo"""

        # Simula progresso baseado na fórmula: P_t = αE_t + (1-α)P_{t-1}
        alpha = 0.3  # Fator de aprendizagem

        # Simula engajamento atual baseado no perfil
        base_engagement = (profile['habilidades_sociais'] +
                         profile['autorregulacao'] +
                         profile['comunicacao']) / 15  # Normaliza para 0-1

        # Adiciona variação temporal
        current_engagement = base_engagement + random.uniform(-0.1, 0.1)
        current_engagement = max(0, min(1, current_engagement))

        # Simula progresso anterior
        if interaction_num == 0:
            previous_progress = base_engagement
        else:
            previous_progress = base_engagement + (interaction_num * 0.001)  # Crescimento gradual

        # Aplica fórmula
        progress = alpha * current_engagement + (1 - alpha) * previous_progress
        return round(progress, 3)

class VygotEAEngine:
    """Motor principal do VygotEA com capacidades de ML"""

    def __init__(self):
        self.vectorizer = TfidfVectorizer(max_features=1000, stop_words='english')
        self.emotion_classifier = LogisticRegression(random_state=42)
        self.interaction_history = []
        self.knowledge_base = {}
        self.trained = False

    def train_emotion_classifier(self, interactions_df: pd.DataFrame):
        """Treina classificador de emoções"""

        print("Treinando classificador de emoções...")

        # Prepara dados de treino
        X = interactions_df['mensagem_estudante'].values
        y = interactions_df['emocao_categoria'].values

        # Vetoriza texto
        X_vectorized = self.vectorizer.fit_transform(X)

        # Divide dados
        X_train, X_test, y_train, y_test = train_test_split(
            X_vectorized, y, test_size=0.2, random_state=42
        )

        # Treina modelo
        self.emotion_classifier.fit(X_train, y_train)

        # Avalia modelo
        y_pred = self.emotion_classifier.predict(X_test)
        accuracy = accuracy_score(y_test, y_pred)

        print(f"Acurácia do classificador: {accuracy:.3f}")
        print("\nRelatório de classificação:")
        print(classification_report(y_test, y_pred))

        self.trained = True
        return accuracy

    def predict_emotion(self, message: str) -> Tuple[str, float]:
        """Prediz emoção de uma mensagem"""

        if not self.trained:
            raise ValueError("Modelo não foi treinado ainda!")

        # Vetoriza mensagem
        message_vec = self.vectorizer.transform([message])

        # Prediz emoção
        prediction = self.emotion_classifier.predict(message_vec)[0]
        probability = self.emotion_classifier.predict_proba(message_vec).max()

        return prediction, probability

    def generate_response(self, message: str, student_profile: Dict) -> Dict:
        """Gera resposta personalizada baseada em ABA e ZDP"""

        if self.trained:
            emotion, confidence = self.predict_emotion(message)
        else:
            emotion, confidence = "ansiedade", 0.5

        # Seleciona estratégia ABA
        aba_strategy = self._select_aba_strategy(emotion)

        # Gera resposta baseada em ZDP
        zdp_level = student_profile.get('nivel_desenvolvimento', 'intermediario')
        response = self._generate_adaptive_response(emotion, zdp_level, aba_strategy)

        return {
            'emotion_detected': emotion,
            'confidence': confidence,
            'aba_strategy': aba_strategy,
            'zdp_level': zdp_level,
            'response': response,
            'timestamp': datetime.now()
        }

    def _select_aba_strategy(self, emotion: str) -> str:
        """Seleciona estratégia ABA baseada na emoção"""

        strategies = {
            'ansiedade': 'autorregulacao',
            'frustacao': 'habilidades_sociais',
            'tristeza': 'comunicacao',
            'alegria': 'reforco_positivo',
            'medo': 'dessensibilizacao_sistematica',
            'calma': 'manutencao_estado'
        }

        return strategies.get(emotion, 'comunicacao')

    def _generate_adaptive_response(self, emotion: str, zdp_level: str, aba_strategy: str) -> str:
        """Gera resposta adaptativa baseada em ZDP"""

        responses = {
            'ansiedade': {
                'inicial': "Vejo que você está preocupado. Vamos respirar fundo juntos?",
                'intermediario': "Entendo sua ansiedade. Que tal usarmos uma técnica de relaxamento?",
                'avancado': "Reconheço seus sentimentos ansiosos. Vamos desenvolver estratégias de enfrentamento personalizadas?"
            },
            'frustacao': {
                'inicial': "Percebo que você está chateado. Vamos conversar sobre isso?",
                'intermediario': "Sua frustração é compreensível. Vamos encontrar uma solução juntos?",
                'avancado': "Entendo sua frustração. Vamos analisar a situação e desenvolver estratégias adaptativas?"
            },
            'tristeza': {
                'inicial': "Vejo que você está triste. Estou aqui para ajudar.",
                'intermediario': "Entendo que você está se sentindo triste. Vamos conversar sobre o que pode ajudar?",
                'avancado': "Percebo sua tristeza. Vamos explorar estratégias de regulação emocional apropriadas?"
            },
            'alegria': {
                'inicial': "Que bom que você está feliz! Conte-me mais.",
                'intermediario': "Sua alegria é contagiante! Como podemos manter esse sentimento?",
                'avancado': "Maravilhoso saber que você está alegre! Vamos usar essa energia positiva para outras áreas?"
            },
            'medo': {
                'inicial': "Entendo que você tem medo. Vamos enfrentar isso juntos.",
                'intermediario': "Seus medos são válidos. Vamos trabalhar estratégias para se sentir mais seguro?",
                'avancado': "Compreendo seus medos. Vamos desenvolver um plano gradual de enfrentamento?"
            },
            'calma': {
                'inicial': "Que bom que você está calmo! Vamos aproveitar esse momento.",
                'intermediario': "Sua tranquilidade é admirável. Como conseguiu alcançar essa calma?",
                'avancado': "Excelente estado de equilíbrio! Vamos consolidar essas estratégias de autorregulação?"
            }
        }

        return responses.get(emotion, {}).get(zdp_level,
                                           "Estou aqui para apoiá-lo. Vamos conversar sobre como você está se sentindo?")

class VygotEAAnalyzer:
    """Analisador de dados e gerador de insights"""

    def __init__(self, interactions_df: pd.DataFrame):
        self.interactions_df = interactions_df

    def generate_comprehensive_analysis(self):
        """Gera análise abrangente dos dados"""

        print("=== ANÁLISE ABRANGENTE DOS DADOS DO VYGOTEA ===\n")

        # Estatísticas básicas
        self._basic_statistics()

        # Análise de emoções
        self._emotion_analysis()

        # Análise de progresso
        self._progress_analysis()

        # Análise de estratégias ABA
        self._aba_strategies_analysis()

        # Análise de satisfação
        self._satisfaction_analysis()

        # Visualizações
        self._create_visualizations()

    def _basic_statistics(self):
        """Estatísticas básicas do dataset"""

        print("1. ESTATÍSTICAS BÁSICAS")
        print("-" * 50)
        print(f"Total de interações: {len(self.interactions_df)}")
        print(f"Número de perfis de estudantes: {self.interactions_df['student_profile'].nunique()}")
        print(f"Período de dados: {self.interactions_df['timestamp'].min()} a {self.interactions_df['timestamp'].max()}")
        print(f"Duração média das interações: {self.interactions_df['duracao_interacao'].mean():.2f} segundos")
        print(f"Satisfação média: {self.interactions_df['satisfacao_resposta'].mean():.2f}/5.0")
        print()

    def _emotion_analysis(self):
        """Análise de distribuição emocional"""

        print("2. ANÁLISE DE EMOÇÕES")
        print("-" * 50)

        emotion_counts = self.interactions_df['emocao_categoria'].value_counts()
        print("Distribuição de emoções:")
        for emotion, count in emotion_counts.items():
            percentage = (count / len(self.interactions_df)) * 100
            print(f"  {emotion}: {count} ({percentage:.1f}%)")

        # Análise por perfil
        print("\nEmoções por perfil de estudante:")
        emotion_profile = pd.crosstab(self.interactions_df['student_profile'],
                                    self.interactions_df['emocao_categoria'])
        print(emotion_profile)
        print()

    def _progress_analysis(self):
        """Análise de progresso dos estudantes"""

        print("3. ANÁLISE DE PROGRESSO")
        print("-" * 50)

        # Progresso por perfil
        progress_by_profile = self.interactions_df.groupby('student_profile')['progresso_adaptativo'].agg(['mean', 'std'])
        print("Progresso médio por perfil:")
        print(progress_by_profile)

        # Correlação entre progresso e satisfação
        correlation = self.interactions_df['progresso_adaptativo'].corr(self.interactions_df['satisfacao_resposta'])
        print(f"\nCorrelação progresso-satisfação: {correlation:.3f}")
        print()

    def _aba_strategies_analysis(self):
        """Análise das estratégias ABA utilizadas"""

        print("4. ANÁLISE DE ESTRATÉGIAS ABA")
        print("-" * 50)

        strategy_counts = self.interactions_df['estrategia_aba'].value_counts()
        print("Estratégias mais utilizadas:")
        for strategy, count in strategy_counts.head(10).items():
            percentage = (count / len(self.interactions_df)) * 100
            print(f"  {strategy}: {count} ({percentage:.1f}%)")

        # Eficácia das estratégias (baseada na satisfação)
        strategy_effectiveness = self.interactions_df.groupby('estrategia_aba')['satisfacao_resposta'].mean().sort_values(ascending=False)
        print("\nEficácia das estratégias (top 5):")
        for strategy, satisfaction in strategy_effectiveness.head().items():
            print(f"  {strategy}: {satisfaction:.2f}/5.0")
        print()

    def _satisfaction_analysis(self):
        """Análise de satisfação"""

        print("5. ANÁLISE DE SATISFAÇÃO")
        print("-" * 50)

        # Satisfação por nível ZDP
        satisfaction_by_zdp = self.interactions_df.groupby('nivel_zdp')['satisfacao_resposta'].agg(['mean', 'std'])
        print("Satisfação por nível ZDP:")
        print(satisfaction_by_zdp)

        # Satisfação por duração da interação
        self.interactions_df['duracao_categoria'] = pd.cut(self.interactions_df['duracao_interacao'],
                                                         bins=[0, 60, 120, 300],
                                                         labels=['Curta', 'Média', 'Longa'])
        satisfaction_by_duration = self.interactions_df.groupby('duracao_categoria')['satisfacao_resposta'].mean()
        print("\nSatisfação por duração da interação:")
        print(satisfaction_by_duration)
        print()

    def _create_visualizations(self):
        """Cria visualizações dos dados"""

        print("6. GERANDO VISUALIZAÇÕES")
        print("-" * 50)

        # Configura estilo
        plt.style.use('seaborn-v0_8')
        fig, axes = plt.subplots(2, 3, figsize=(18, 12))
        fig.suptitle('Análise Abrangente do VygotEA', fontsize=16, fontweight='bold')

        # 1. Distribuição de emoções
        emotion_counts = self.interactions_df['emocao_categoria'].value_counts()
        axes[0, 0].pie(emotion_counts.values, labels=emotion_counts.index, autopct='%1.1f%%')
        axes[0, 0].set_title('Distribuição de Emoções')

        # 2. Progresso por perfil
        progress_by_profile = self.interactions_df.groupby('student_profile')['progresso_adaptativo'].mean()
        axes[0, 1].bar(progress_by_profile.index, progress_by_profile.values)
        axes[0, 1].set_title('Progresso Médio por Perfil')
        axes[0, 1].set_ylabel('Progresso Adaptativo')
        axes[0, 1].tick_params(axis='x', rotation=45)

        # 3. Satisfação por nível ZDP
        satisfaction_by_zdp = self.interactions_df.groupby('nivel_zdp')['satisfacao_resposta'].mean()
        axes[0, 2].bar(satisfaction_by_zdp.index, satisfaction_by_zdp.values, color='green', alpha=0.7)
        axes[0, 2].set_title('Satisfação por Nível ZDP')
        axes[0, 2].set_ylabel('Satisfação Média')

        # 4. Correlação progresso-satisfação
        axes[1, 0].scatter(self.interactions_df['progresso_adaptativo'],
                          self.interactions_df['satisfacao_resposta'], alpha=0.6)
        axes[1, 0].set_title('Correlação Progresso-Satisfação')
        axes[1, 0].set_xlabel('Progresso Adaptativo')
        axes[1, 0].set_ylabel('Satisfação')

        # 5. Estratégias ABA mais utilizadas
        strategy_counts = self.interactions_df['estrategia_aba'].value_counts().head(8)
        axes[1, 1].barh(strategy_counts.index, strategy_counts.values)
        axes[1, 1].set_title('Estratégias ABA Mais Utilizadas')
        axes[1, 1].set_xlabel('Frequência')

        # 6. Evolução temporal do progresso
        self.interactions_df['data'] = self.interactions_df['timestamp'].dt.date
        progress_temporal = self.interactions_df.groupby('data')['progresso_adaptativo'].mean()
        axes[1, 2].plot(progress_temporal.index, progress_temporal.values)
        axes[1, 2].set_title('Evolução Temporal do Progresso Médio')
        axes[1, 2].set_xlabel('Data')
        axes[1, 2].set_ylabel('Progresso Médio')
        axes[1, 2].tick_params(axis='x', rotation=45)

        plt.tight_layout(rect=[0, 0.03, 1, 0.95])
        plt.show()
